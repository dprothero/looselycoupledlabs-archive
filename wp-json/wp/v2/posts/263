{"id":263,"date":"2015-07-04T22:54:48","date_gmt":"2015-07-04T22:54:48","guid":{"rendered":"http:\/\/looselycoupledlabs.com\/?p=263"},"modified":"2015-07-04T22:54:48","modified_gmt":"2015-07-04T22:54:48","slug":"masstransit-3-update-a-simple-publishsubscribe-example","status":"publish","type":"post","link":"https:\/\/looselycoupledlabs.com\/2015\/07\/masstransit-3-update-a-simple-publishsubscribe-example\/","title":{"rendered":"MassTransit 3 Update: A Simple Publish\/Subscribe Example"},"content":{"rendered":"<p>With the <a href=\"http:\/\/blog.phatboyg.com\/2014\/11\/30\/masstransit\/\" target=\"_blank\">announcement of MassTransit 3<\/a>, we learned that there were many <a href=\"http:\/\/blog.phatboyg.com\/2015\/02\/24\/masstransit-3-api-changes\/\" target=\"_blank\">changes to the API<\/a> that were coming. The changes are all welcome ones, making MassTransit 3 simpler to work with and now completely asynchronous. What follows is this blog&#8217;s\u00a0inaugural post, but updated to work with the current pre-release version of MassTransit 3. <!--more--><\/p>\n<div class=\"alert info\">Whenever there is an MT3 specific update, I will call it out like this.<\/div>\n<p>When I first sat down to learn how to use <a title=\"MassTransit Project Site\" href=\"http:\/\/masstransit-project.com\/\" target=\"_blank\">MassTransit<\/a>, I found it difficult to just get a simple example that published a message onto the bus with another process that subscribed to messages of the same type working. Hopefully, this primer will get you on the bus quicker.<\/p>\n<h1>Setting Up Your Environment<\/h1>\n<p>The first thing you need is a message queuing framework. MassTransit supports <del>MSMQ<\/del>, RabbitMQ, and others, but I find that RabbitMQ is really the way to go. That\u2019s especially true when using the publish\/subscribe pattern. The reason for this is that RabbitMQ has a complete routing framework built-in and MassTransit will leverage this when persisting your subscriptions. When creating a cluster of RabbitMQ servers for availability, this routing information is replicated to all the nodes.<\/p>\n<div class=\"alert info\">MT3 has dropped support for MSMQ (<a href=\"http:\/\/blog.phatboyg.com\/2014\/11\/30\/masstransit\/#outwiththeold\" target=\"_blank\">read about that<\/a>) but has officially adopted Azure Service Bus as an in-the-box supported transport.<\/div>\n<p>In this article, you\u2019re going to run RabbitMQ on your local Windows development box. Both our publisher and subscriber will connect to the same RabbitMQ instance. In a future post, I\u2019ll detail how to set up multiple RabbitMQ instances in a cluster.<\/p>\n<h2>Installing RabbitMQ<\/h2>\n<p>RabbitMQ requires the Erlang runtime, so that\u2019s the first thing you need to download and install. Head over to <a href=\"http:\/\/www.erlang.org\/download.html\" target=\"_blank\">Erlang.org\u2019s download page<\/a> and get the latest binary release for Windows (it\u2019s likely you\u2019ll want the 64-bit version). It\u2019s a simple setup wizard, so you\u2019ll have Erlang installed on your machine in short order.<\/p>\n<p>Next, <a href=\"http:\/\/www.rabbitmq.com\/download.html\" target=\"_blank\">download the latest version of RabbitMQ<\/a> for Windows. Again, it\u2019s an easy setup wizard that you can quickly fly through. Just accept the defaults.<\/p>\n<h2>Enabling the RabbitMQ Web Management Interface<\/h2>\n<p>One RabbitMQ feature that I found extremely useful (but which isn\u2019t enabled by default) is the web-based management interface. With this, you can see the exchanges and queues that are set up by MassTransit in RabbitMQ. To enable this, find the \u201cRabbitMQ Command Prompt (sbin dir)\u201d item that the RabbitMQ installer added to your Start menu and launch it. From the command line, run the following command:<\/p>\n<pre class=\"brush: ps; toolbar: false;\">&gt; rabbitmq-plugins enable rabbitmq_management<\/pre>\n<p>It will confirm that the plugin and its dependencies have been enabled and instruct you to restart RabbitMQ. When installed on Windows, RabbitMQ runs as a Windows service. You can use the Services MMC snap-in to restart it or just run the following command:<\/p>\n<pre class=\"brush: ps; toolbar: false;\">&gt; net service stop RabbitMQ\r\n...\r\n&gt; net service start RabbitMQ<\/pre>\n<p>Now go to <a href=\"http:\/\/localhost:15672\/\">http:\/\/localhost:15672\/<\/a> to open the management console. Default credentials to login are guest\/guest (you can change the credentials from the Admin tab).<\/p>\n<p>There\u2019s not much to see yet, but we\u2019ll set the stage. Go to the Exchanges tab. You\u2019ll see the following default RabbitMQ exchanges:<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb.png\" alt=\"image\" width=\"325\" height=\"213\" border=\"0\" \/><\/a><\/p>\n<p>An exchange is something you can send messages to. It cannot hold messages. It\u2019s merely a set of routing instructions that tell RabbitMQ where to deliver the message. We\u2019ll come back here in a little while.<\/p>\n<p>Now click on the Queues tab. Nothing here yet. Queues can actually hold messages and are where applications can actually pick up messages.<\/p>\n<p>So, to use a real world analogy, an Exchange is like the local Post Office, and a Queue is like your mailbox. The only thing that an Exchange can do that most traditional Post Offices don\u2019t do is actually make multiple copies of a message to be delivered to multiple mailboxes.<\/p>\n<h1>Creating the Sample Applications<\/h1>\n<p>I used Visual Studio 2013 to create this sample, but it should work in 2012 as well. You can get the entire source from: <a href=\"https:\/\/github.com\/dprothero\/MtPubSubExample\">https:\/\/github.com\/dprothero\/MtPubSubExample<\/a><\/p>\n<div class=\"alert info\">To view the code for MT3, select the &#8220;mt3&#8221; branch in this GitHub repository.<\/div>\n<h2>Creating a Contract<\/h2>\n<p>I like to use the concept of a \u201ccontract\u201d for my messages I want to put onto the service bus. This is an interface definition that both the publisher and subscriber have to agree upon. They don\u2019t need to know anything about the implementation of this interface on either side. To keep the publisher and subscriber as loosely coupled as possible, I like to put my contracts in their own assembly so that this is the only shared dependency.<\/p>\n<p>So, the first step is to create a new solution called MtPubSubExample and a new class library called \u201cContracts\u201d. To the class library, add a single interface called \u201cSomethingHappened.\u201d<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">using System;\r\n\r\nnamespace Contracts\r\n{\r\n  public interface SomethingHappened\r\n  {\r\n    string What { get; }\r\n    DateTime When { get; }\r\n  }\r\n}<\/pre>\n<p>SomethingHappened will be the message interface we use for our sample message. Our publisher will create an instance of a class implementing SomethingHappened, set What and When properties, and publish it onto the service bus.<\/p>\n<p>Our subscriber will then set up a subscription (aka Consumer) to listen for all messages of type SomethingHappened. MassTransit will call our Consumer class whenever a SomethingHappened message is received, and we can handle it as we wish, presumably inspecting the What and the When properties.<\/p>\n<h2>Shared Configuration Setup Code<\/h2>\n<div class=\"alert info\">The original article used a separate Configuration class to handle the common configuration tasks for both the publisher and subscriber. MT3&#8217;s configuration code is much simpler and, for clarity, I&#8217;ve moved the appropriate code into the publisher and subscriber.<\/div>\n<h2>Creating the Publisher<\/h2>\n<p>We\u2019ll make the publisher a very simple console application that just prompts the user for some text and then publishes that text as part of a SomethingHappened message. Add a new Console Application project called \u201cTestPublisher\u201d to the solution and add a new class called \u201cSomethingHappenedMessage.\u201d This will be our concrete implementation of the SomethingHappened interface. You\u2019ll need to add a project reference to the Contracts project.<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">using Contracts;\r\nusing System;\r\n\r\nnamespace TestPublisher\r\n{\r\n  class SomethingHappenedMessage : SomethingHappened\r\n  {\r\n    public string What { get; set; }\r\n    public DateTime When { get; set; }\r\n  }\r\n}<\/pre>\n<p>Now, in the Main method of the Program.cs file in your Console Application, you can put in the code to set up the bus, prompt the user for text, and publish that text onto the bus. Real quick first, however, it\u2019s time to head to NuGet and pull in MassTransit. The quickest way to get everything you need is to find the MassTransit.RabbitMq package and install that. Doing so will install all of MassTransit and its dependencies.<\/p>\n<p>You still need one more package. I found that MassTransit doesn\u2019t work unless you install one of the logging integration packages that are designed for it. For me, I selected the Log4Net integration package (MassTransit.Log4Net).<\/p>\n<div class=\"alert info\">To get the pre-release version of MassTransit 3 you need to add the -Pre flag to the Install-Package commands in the Package Manager Console:<\/p>\n<pre>Install-Package -Pre MassTransit.RabbitMq\r\nInstall-Package -Pre Masstransit.Log4Net<\/pre>\n<\/div>\n<pre class=\"brush: csharp; toolbar: false;\">using System;\r\nusing Contracts;\r\nusing MassTransit;\r\nusing MassTransit.Log4NetIntegration.Logging;\r\n\r\nnamespace TestPublisher\r\n{\r\n  class Program\r\n  {\r\n    static void Main(string[] args)\r\n    {\r\n      Log4NetLogger.Use();\r\n      var bus = Bus.Factory.CreateUsingRabbitMq(x =&gt; \r\n        x.Host(new Uri(\"rabbitmq:\/\/localhost\/\"), h =&gt; { }));\r\n      var busHandle = bus.Start();\r\n      var text = \"\";\r\n\r\n      while (text != \"quit\")\r\n      {\r\n        Console.Write(\"Enter a message: \");\r\n        text = Console.ReadLine();\r\n\r\n        var message = new SomethingHappenedMessage()\r\n        {\r\n          What = text, When = DateTime.Now\r\n        };\r\n        bus.Publish&lt;SomethingHappened&gt;(message);\r\n      }\r\n\r\n      busHandle.Stop().Wait();\r\n    }\r\n  }\r\n}<\/pre>\n<div class=\"alert info\">In MT3, most operations are asynchronous, including the Publish() method. However, there is no need to await the call to publish here.<\/div>\n<p>Pretty simple, huh? We put the input capture and message publishing in a loop to make it easy to send multiple messages. Just put a catch for the string \u201cquit\u201d so we can exit the publisher when we\u2019d like.<\/p>\n<div class=\"alert info\">MT3 now requires an explicit call to start the bus, returning a handle that you can use to later stop the bus. Notice the Wait() method chained to the Stop() method. This is because the Stop() method is asynchronous. If you were calling Stop() inside an async method, you could await it. However, since this is a simple Console app, we are just blocking the thread until the shutdown is complete.<\/div>\n<p>If you make TestPublisher the startup project of the solution and run it, right now you can publish messages all you like\u2026. However, nobody is listening yet!<\/p>\n<h2>What\u2019s Going on in RabbitMQ So Far?<\/h2>\n<p>If you go back into the RabbitMQ web interface and jump over to the Exchanges tab, you\u2019ll see we have a <del>couple<\/del> new arrival<del>s<\/del>.<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image4.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image4_thumb.png\" alt=\"image\" width=\"340\" height=\"214\" border=\"0\" \/><\/a><\/p>\n<div class=\"alert info\">MT3 doesn&#8217;t require creating a queue if you aren&#8217;t hosting\u00a0an endpoint. So, for our publisher, the MtPubSubExample_TestPublisher queue will not be created as it was in the original post.<\/div>\n<p>Contracts:SomethingHappened is a new exchange created for the SomethingHappened message type. When we published this message, MassTransit automatically created this exchange. Click on it and scroll down to the Bindings section, and you\u2019ll see there are no bindings yet:<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image1.png\"><img loading=\"lazy\" style=\"border-width: 0px; margin: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb1.png\" alt=\"image\" width=\"152\" height=\"143\" border=\"0\" \/><\/a><\/p>\n<p>That\u2019s because nobody has subscribed to SomethingHappened messages yet. They go to the exchange and then die because there\u2019s no queue to route them to.<\/p>\n<h2>Creating the Subscriber<\/h2>\n<p>The final piece of the puzzle! Add another Console Application project to your solution and call it TestSubscriber. Again, add project references to Contracts and Configuration and then add the MassTransit.RabbitMq and MassTransit.Log4Net\u00a0NuGet packages.<\/p>\n<div class=\"alert info\">Don&#8217;t forget the -Pre switch to get the pre-release version of MT3.<\/div>\n<p>The first thing we need is a Consumer class to consume the SomethingHappened messages. Add a new class to the console app and call it \u201cSomethingHappenedConsumer.\u201d<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">using System;\r\nusing System.Threading.Tasks;\r\nusing Contracts;\r\nusing MassTransit;\r\n\r\nnamespace TestSubscriber\r\n{\r\n  class SomethingHappenedConsumer : IConsumer&lt;SomethingHappened&gt;\r\n  {\r\n    public Task Consume(ConsumeContext&lt;SomethingHappened&gt; context)\r\n    {\r\n      Console.Write(\"TXT: \" + context.Message.What);\r\n      Console.Write(\"  SENT: \" + context.Message.When);\r\n      Console.Write(\"  PROCESSED: \" + DateTime.Now);\r\n      Console.WriteLine(\" (\" + System.Threading.Thread.CurrentThread.ManagedThreadId + \")\");\r\n      return Task.FromResult(0);\r\n    }\r\n  }\r\n}<\/pre>\n<p>This consumer class implements a specific MassTransit interface whose Consume method will be called with the message context and SomethingHappened message each time a message is received. Here we are simply writing the message out to the console.<\/p>\n<div class=\"alert info\">The Consume method is meant to be asynchronous, so it returns a Task. In this example, we aren&#8217;t making any other asynchronous calls, so we just use the Task.FromResult() helper method to return a Task with a zero result. If you were doing something asynchronous in the Consume method you could use async\/await:<\/p>\n<pre>public <span style=\"background-color: yellow;\">async<\/span> Task Consume(ConsumeContext&lt;SomethingHappened&gt; context)\r\n{\r\n  <span style=\"background-color: yellow;\">await<\/span> SomeAsynchronousMethod(context.Message);\r\n}<\/pre>\n<\/div>\n<p>Finally, in the Main method of Program.cs, we can initialize the bus and, as part of the initialization, instruct MassTransit that we wish to subscribe to messages of type SomethingHappened.<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">using System;\r\nusing MassTransit;\r\nusing MassTransit.Log4NetIntegration.Logging;\r\n\r\nnamespace TestSubscriber\r\n{\r\n  class Program\r\n  {\r\n    static void Main(string[] args)\r\n    {\r\n      Log4NetLogger.Use();\r\n      var bus = Bus.Factory.CreateUsingRabbitMq(x =&gt;\r\n      {\r\n        var host = x.Host(new Uri(\"rabbitmq:\/\/localhost\/\"), h =&gt; { });\r\n\r\n        x.ReceiveEndpoint(host, \"MtPubSubExample_TestSubscriber\", e =&gt;\r\n          e.Consumer&lt;SomethingHappenedConsumer&gt;());\r\n      });\r\n      var busHandle = bus.Start();\r\n      Console.ReadKey();\r\n      busHandle.Stop().Wait();\r\n    }\r\n  }\r\n}<\/pre>\n<div class=\"alert info\">Notice we are now passing a queue name to the new ReceiveEndpoint MT3 method. Make sure not to share this queue name with other applications.<\/div>\n<p>Now right-click on the MtPubSubExample solution in the solution explorer and choose \u201cSet Startup Projects\u2026.\u201d From here, choose the Multiple startup projects option and set the Action for both TestPublisher and TestSubscriber to Start. Now when you run your solution, both the publisher and subscriber will run.<\/p>\n<p>Type some messages into the publisher. You should see them show up immediately in the subscriber window!<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image10.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image10_thumb.png\" alt=\"image\" width=\"570\" height=\"212\" border=\"0\" \/><\/a><\/p>\n<p>Now close <em>just<\/em> the Subscriber sample window and publish a few more messages in the Publisher window.<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image2.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb2.png\" alt=\"image\" width=\"432\" height=\"213\" border=\"0\" \/><\/a><\/p>\n<p>Go ahead and close the Publisher window for now. Let\u2019s take a deeper look at where those three messages went.<\/p>\n<h2>What\u2019s Going on in RabbitMQ Now?<\/h2>\n<p>Go back into the RabbitMQ web interface and go back to the Exchanges tab. You\u2019ll see a new exchange called MtPubSubExample_TestSubscriber, but first click on the Contracts:SomethingHappened exchange and scroll down to the Bindings section. You\u2019ll see we now have a binding.<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image3.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb3.png\" alt=\"image\" width=\"534\" height=\"207\" border=\"0\" \/><\/a><\/p>\n<p>So, by creating a subscription from our TestSubscriber, MassTransit automatically set up this binding for us. Click on the MtPubSubExample_TestSubscriber here, and you\u2019ll see you\u2019re taken to the setup page for an exchange called MtPubSubExample_TestSubscriber. Scroll down to Bindings, and you\u2019ll see we\u2019re bound to a queue named the same as the exchange (in the binding diagrams, exchanges show up as rectangles with rounded corners, whereas queues have straight corners).<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image5.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb4.png\" alt=\"image\" width=\"531\" height=\"331\" border=\"0\" \/><\/a><\/p>\n<p>The web interface is great in how it shows the predecessor in addition to the successor in the path. Click the MtPubSubExample_TestSubscriber queue here, and you\u2019ll be taken to the queue setup page for that queue. If you haven\u2019t fired up the TestSubscriber app since we published those last three messages, you should see that there are three messages in the queue:<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image6.png\"><img loading=\"lazy\" style=\"border-width: 0px; margin: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb5.png\" alt=\"image\" width=\"219\" height=\"103\" border=\"0\" \/><\/a><\/p>\n<p>Fire up the TestSubscriber app, and you should see it process the three messages left in the queue.<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image7.png\"><img loading=\"lazy\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/06\/image_thumb6.png\" alt=\"image\" width=\"563\" height=\"123\" border=\"0\" \/><\/a><\/p>\n<p>Notice the timestamp from the message versus the timestamp of when the subscriber actually published the message. In this case, there was a 6-minute lag (the 6 minutes we were poking around in RabbitMQ before starting up the subscriber again).<\/p>\n<h1>Wrap Up<\/h1>\n<p>Hopefully, this post was helpful in getting you off the ground with MassTransit 3. I will work on updating more posts like this one.<\/p>\n<p>Until then\u2026<\/p>\n","protected":false},"excerpt":{"rendered":"<p>With the announcement of MassTransit 3, we learned that there were many changes to the API that were coming. The changes are all welcome ones, making MassTransit 3 simpler to work with and now completely asynchronous. What follows is this blog&#8217;s\u00a0inaugural post, but updated to work with the current pre-release version of MassTransit 3.<\/p>\n","protected":false},"author":1,"featured_media":37,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[6],"tags":[2,10,3,4,5],"_links":{"self":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts\/263"}],"collection":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/comments?post=263"}],"version-history":[{"count":10,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts\/263\/revisions"}],"predecessor-version":[{"id":279,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts\/263\/revisions\/279"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/media\/37"}],"wp:attachment":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/media?parent=263"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/categories?post=263"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/tags?post=263"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}