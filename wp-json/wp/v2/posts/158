{"id":158,"date":"2014-08-20T03:52:58","date_gmt":"2014-08-20T03:52:58","guid":{"rendered":"http:\/\/looselycoupledlabs.com\/?p=158"},"modified":"2014-08-20T04:40:33","modified_gmt":"2014-08-20T04:40:33","slug":"monitoring-rabbitmq","status":"publish","type":"post","link":"https:\/\/looselycoupledlabs.com\/2014\/08\/monitoring-rabbitmq\/","title":{"rendered":"Monitoring RabbitMQ"},"content":{"rendered":"<p>We\u2019ve talked a lot about using <a href=\"http:\/\/masstransit-project.com\/\" target=\"_blank\">MassTransit<\/a> with <a href=\"http:\/\/www.rabbitmq.com\/\" target=\"_blank\">RabbitMQ<\/a> in a variety of scenarios on this blog. We talked about <a href=\"http:\/\/looselycoupledlabs.com\/2014\/07\/error-handling-in-masstransit-consumers\/\">error handling<\/a>, which is something you need to know how to implement in a real world MassTransit + RabbitMQ deployment. Another important aspect to a production deployment is monitoring. Lets take a look at how we can leverage the <a href=\"http:\/\/hg.rabbitmq.com\/rabbitmq-management\/raw-file\/3646dee55e02\/priv\/www-api\/help.html\" target=\"_blank\">RabbitMQ Management HTTP API<\/a> (installed with the <a href=\"http:\/\/www.rabbitmq.com\/management.html\" target=\"_blank\">RabbitMQ Management Plugin<\/a>) to query our queues so we can monitor the health of our service bus.<\/p>\n<h1>Enabling the RabbitMQ Management Plugin<\/h1>\n<p>In <a href=\"http:\/\/looselycoupledlabs.com\/2014\/06\/masstransit-publish-subscribe-example\/\">A Simple MassTransit Publish\/Subscribe Example<\/a>, I detailed how to install RabbitMQ on Windows along with the RabbitMQ Management Plugin. You can refer to that post for the full details, but it\u2019s important to know the RabbitMQ Management Plugin isn\u2019t installed out of the box. One simple command will install it:<\/p>\n<pre class=\"brush: ps; toolbar: false;\">&gt; rabbitmq-plugins enable rabbitmq_management\r\n<\/pre>\n<p>After a restart of the RabbitMQ service, visiting <a href=\"http:\/\/localhost:15672\/\" target=\"_blank\">http:\/\/localhost:15672\/<\/a> should bring you to the management GUI (default credentials are guest\/guest). The HTTP API is available at <a title=\"http:\/\/localhost:15672\/api\/\" href=\"http:\/\/localhost:15672\/api\/\" target=\"_blank\">http:\/\/localhost:15672\/api\/<\/a>.<\/p>\n<h2><\/h2>\n<h2>Simple REST API Call<\/h2>\n<p>Type the following URL into your browser to get a list of queues in your RabbitMQ instance:<\/p>\n<p><a title=\"http:\/\/localhost:15672\/api\/queues\" href=\"http:\/\/localhost:15672\/api\/queues\" target=\"_blank\">http:\/\/localhost:15672\/api\/queues<\/a><\/p>\n<p>You will need to supply the guest\/guest credentials to access the API method. You should see the list of queues returned as JSON. If you want to get data for a single, specific queue, use the url format \/api\/queues\/<em>vhost<\/em>\/<em>queue-name<\/em>. The default vhost in RabbitMQ is \u201c\/\u201d which URL encoded is %2F, so the the URL to retrieve info for the queue named MtPubSubExample_TestSubscriber would be <a title=\"http:\/\/localhost:15672\/api\/queues\/%2F\/MtPubSubExample_TestSubscriber\" href=\"http:\/\/localhost:15672\/api\/queues\/%2F\/MtPubSubExample_TestSubscriber\" target=\"_blank\">http:\/\/localhost:15672\/api\/queues\/%2F\/MtPubSubExample_TestSubscriber<\/a> and that would return the following JSON:<\/p>\n<pre class=\"brush: js; toolbar: false;\">{\r\n   \"memory\":21856,\r\n   \"messages\":1,\r\n   \"messages_details\":{\r\n      \"rate\":0.0\r\n   },\r\n   \"messages_ready\":1,\r\n   \"messages_ready_details\":{\r\n      \"rate\":0.0\r\n   },\r\n   \"messages_unacknowledged\":0,\r\n   \"messages_unacknowledged_details\":{\r\n      \"rate\":0.0\r\n   },\r\n   \"idle_since\":\"2014-08-16 9:30:50\",\r\n   \"consumer_utilisation\":\"\",\r\n   \"policy\":\"\",\r\n   \"exclusive_consumer_tag\":\"\",\r\n   \"consumers\":0,\r\n   \"backing_queue_status\":{\r\n      \"q1\":0,\r\n      \"q2\":0,\r\n      \"delta\":[\r\n         \"delta\",\r\n         \"undefined\",\r\n         0,\r\n         \"undefined\"\r\n      ],\r\n      \"q3\":1,\r\n      \"q4\":0,\r\n      \"len\":1,\r\n      \"pending_acks\":0,\r\n      \"target_ram_count\":\"infinity\",\r\n      \"ram_msg_count\":0,\r\n      \"ram_ack_count\":0,\r\n      \"next_seq_id\":180224,\r\n      \"persistent_count\":1,\r\n      \"avg_ingress_rate\":0.0,\r\n      \"avg_egress_rate\":0.0,\r\n      \"avg_ack_ingress_rate\":0.0,\r\n      \"avg_ack_egress_rate\":0.0\r\n   },\r\n   \"state\":\"running\",\r\n   \"incoming\":[\r\n\r\n   ],\r\n   \"deliveries\":[\r\n\r\n   ],\r\n   \"consumer_details\":[\r\n\r\n   ],\r\n   \"name\":\"MtPubSubExample_TestSubscriber\",\r\n   \"vhost\":\"\/\",\r\n   \"durable\":true,\r\n   \"auto_delete\":false,\r\n   \"arguments\":{\r\n\r\n   },\r\n   \"node\":\"rabbit@PROWIN1\"\r\n}\r\n<\/pre>\n<p>In this snippet of JSON you can see the queue has a single message in it. Now, let\u2019s see what we can do with this new knowledge to keep tabs on our queues.<\/p>\n<h1>What to Monitor<\/h1>\n<p>At a minimum, I would monitor the number of ready messages in your queues. What constitutes an alerting threshold obviously will depend on your application. If you expect to have fairly real-time processing of your messages, and have the necessary horsepower in your consumer(s) to keep up, then you might alert if the queue goes over 10 unprocessed messages. You just need to decide how sensitive you need it to be. I\u2019ll show you how to get the data out.<\/p>\n<p>Which queues should you monitor? Any queue you expect to receive messages likely warrants monitoring. This means, for example, in our <a href=\"http:\/\/looselycoupledlabs.com\/2014\/06\/masstransit-publish-subscribe-example\/\">simple publish\/subscribe example<\/a>, we would monitor the MtPubSubExample_TestSubscriber queue. We also will want to monitor the corresponding error queue (e.g. MtPubSubExample_TestSubscriber_error). In our <a href=\"http:\/\/looselycoupledlabs.com\/2014\/07\/a-real-world-masstransit-customer-portal-example\/\">customer portal example<\/a>, we would monitor Loosely_CustomerPortal_Backend and Loosely_CustomerPortal_Backend_error.<\/p>\n<h1>How to Monitor<\/h1>\n<p>This is largely up to you and what monitoring tools you already have in place. Most monitoring tools such as Nagios, NewRelic, AlertSite, and System Center will have some notion of a custom counter or metric that you can have the system monitor and send alerts when they reach a certain threshold. If your selected monitoring tool has a RabbitMQ plugin, you\u2019re in luck. Otherwise, you will need to write a small script to supply the data points to your monitoring system. Let\u2019s take a look at how to do this in C#.<\/p>\n<h2>Checking Your RabbitMQ Queues in C#<\/h2>\n<p>The code for this sample is available on github at <a href=\"https:\/\/github.com\/dprothero\/Loosely.RabbitMq.Monitor\" target=\"_blank\">https:\/\/github.com\/dprothero\/Loosely.RabbitMq.Monitor<\/a>. Clone that repository or follow along here to build the project from scratch. I am using Visual Studio 2013.<\/p>\n<p>First, create a new C# Console project. We can call it Loosely.RabbitMq.Monitor and name the solution something like Loosely.RabbitMq.Utilities. Install the NuGet package Json.NET to your project. That will help us read the JSON response from the web service.<\/p>\n<p>Add a new class file to your project and name it QueueInfo.cs. Delete the QueueInfo class declaration (leaving just the namespace declaration). Copy the JSON code above to your clipboard and then position your cursor within the namespace declaration in QueueInfo.cs. From the Edit menu, select Paste Special, and then Paste JSON as Classes. This will create C# class declarations that will follow your expected JSON. Rename the newly pasted class named Rootobject to QueueInfo. You should end up with the classes below in QueueInfo.cs:<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">namespace Loosely.RabbitMq.Monitor\r\n{\r\n  public class QueueInfo\r\n  {\r\n    public int memory { get; set; }\r\n    public int messages { get; set; }\r\n    public Messages_Details messages_details { get; set; }\r\n    public int messages_ready { get; set; }\r\n    public Messages_Ready_Details messages_ready_details { get; set; }\r\n    public int messages_unacknowledged { get; set; }\r\n    public Messages_Unacknowledged_Details messages_unacknowledged_details { get; set; }\r\n    public string idle_since { get; set; }\r\n    public string consumer_utilisation { get; set; }\r\n    public string policy { get; set; }\r\n    public string exclusive_consumer_tag { get; set; }\r\n    public int consumers { get; set; }\r\n    public Backing_Queue_Status backing_queue_status { get; set; }\r\n    public string state { get; set; }\r\n    public object[] incoming { get; set; }\r\n    public object[] deliveries { get; set; }\r\n    public object[] consumer_details { get; set; }\r\n    public string name { get; set; }\r\n    public string vhost { get; set; }\r\n    public bool durable { get; set; }\r\n    public bool auto_delete { get; set; }\r\n    public Arguments arguments { get; set; }\r\n    public string node { get; set; }\r\n  }\r\n\r\n  public class Messages_Details\r\n  {\r\n    public float rate { get; set; }\r\n  }\r\n\r\n  public class Messages_Ready_Details\r\n  {\r\n    public float rate { get; set; }\r\n  }\r\n\r\n  public class Messages_Unacknowledged_Details\r\n  {\r\n    public float rate { get; set; }\r\n  }\r\n\r\n  public class Backing_Queue_Status\r\n  {\r\n    public int q1 { get; set; }\r\n    public int q2 { get; set; }\r\n    public object[] delta { get; set; }\r\n    public int q3 { get; set; }\r\n    public int q4 { get; set; }\r\n    public int len { get; set; }\r\n    public int pending_acks { get; set; }\r\n    public string target_ram_count { get; set; }\r\n    public int ram_msg_count { get; set; }\r\n    public int ram_ack_count { get; set; }\r\n    public int next_seq_id { get; set; }\r\n    public int persistent_count { get; set; }\r\n    public float avg_ingress_rate { get; set; }\r\n    public float avg_egress_rate { get; set; }\r\n    public float avg_ack_ingress_rate { get; set; }\r\n    public float avg_ack_egress_rate { get; set; }\r\n  }\r\n\r\n  public class Arguments\r\n  {\r\n  }\r\n\r\n}\r\n<\/pre>\n<p>If you wanted, you could clean up the property and class names to better match C# naming conventions. Just be sure to add the necessary JsonProperty attribute so JSON.NET can deserialize the JSON into the correct object properties. For example:<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">[JsonProperty(\"avg_ack_egress_rate\")]\r\npublic float AvgAckEgressRate { get; set; }\r\n<\/pre>\n<p>Note that JSON.NET is case insensitive when deserializing, so you don\u2019t need these attributes if you are only adjusting the case of the identifier (e.g. \u201cname\u201d to \u201cName\u201d).<\/p>\n<p>Next, we could just hard-code the following in Program.cs to get the message count for the MtPubSubExample_TestSubscriber queue:<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">using Newtonsoft.Json;\r\nusing System;\r\nusing System.Net;\r\n\r\nnamespace Loosely.RabbitMq.Monitor\r\n{\r\n  class Program\r\n  {\r\n    static void Main(string[] args)\r\n    {\r\n      var client = new WebClient();\r\n      client.Credentials = new NetworkCredential(\"guest\", \"guest\");\r\n      var data = client.DownloadString(\"http:\/\/localhost:15672\/api\/queues\/%2F\/MtPubSubExample_TestSubscriber\");\r\n      var queueInfo = JsonConvert.DeserializeObject&lt;QueueInfo&gt;(data);\r\n\r\n      Console.WriteLine(\"Queue: \" + queueInfo.Name);\r\n      Console.WriteLine(\"Queue Depth: \" + queueInfo.MessagesReady.ToString());\r\n\r\n      Console.Write(\"\\r\\nPress any key to continue.\");\r\n      Console.ReadKey();\r\n    }\r\n  }\r\n}\r\n<\/pre>\n<p>The code should be pretty straight forward. We make a request to the HTTP API, deserialize the JSON data into a plain old C# object (POCO), and then output the properties we are interested in. However, to make this really useful, we should refactor this code so it can be command line driven. Then, we can simply pass parameters on the command line to tell the program the instance of RabbitMQ to monitor (base URL for the API), the credentials to connect to the server, and the queue we want to interrogate.<\/p>\n<p>For command line argument parsing to a console application, I like to use the <a href=\"http:\/\/www.ndesk.org\/Options\" target=\"_blank\">NDesk.Options<\/a> NuGet package. It makes supporting command line parameters (-x or &#8211;xxxx or \/XXXX) super easy. Add the NDesk.Options package to your project. With that added, we can modify our Program.cs file to the following:<\/p>\n<pre class=\"brush: csharp; toolbar: false;\">using NDesk.Options;\r\nusing Newtonsoft.Json;\r\nusing System;\r\nusing System.Net;\r\n\r\nnamespace Loosely.RabbitMq.Monitor\r\n{\r\n  class Program\r\n  {\r\n    static void Main(string[] args)\r\n    {\r\n      string baseUrl = \"http:\/\/localhost:15672\/api\",\r\n             userName = \"guest\",\r\n             password = \"guest\",\r\n             queueName = null,\r\n             vhost = \"\/\";\r\n\r\n      var p = new OptionSet () {\r\n        { \"u|baseUrl=\",  v =&gt; baseUrl = v },\r\n        { \"U|user=\",     v =&gt; userName = v },\r\n        { \"p|password=\", v =&gt; password = v },\r\n        { \"q|queue=\",    v =&gt; queueName = v },\r\n        { \"v|vhost=\",    v =&gt; vhost = v }\r\n      };\r\n      p.Parse(args);\r\n      \r\n      var client = new WebClient();\r\n      if(userName != null)\r\n        client.Credentials = new NetworkCredential(userName, password);\r\n\r\n      var url = baseUrl + \"\/queues\/\" + Uri.EscapeDataString(vhost) + \"\/\" + Uri.EscapeDataString(queueName);\r\n      var data = client.DownloadString(url);\r\n      var queueInfo = JsonConvert.DeserializeObject&lt;QueueInfo&gt;(data);\r\n\r\n      \/\/ Here is where we report the message count to our monitoring system.\r\n      \/\/ Replace the console output\/wait with your code.\r\n      Console.WriteLine(\"Queue: \" + queueInfo.Name);\r\n      Console.WriteLine(\"Queue Depth: \" + queueInfo.MessagesReady.ToString());\r\n\r\n      Console.Write(\"\\r\\nPress any key to continue.\");\r\n      Console.ReadKey();\r\n    }\r\n  }\r\n}\r\n<\/pre>\n<p>To be able to run from within Visual Studio, you can try out different command line arguments by going to the Debug project properties page:<\/p>\n<p><a href=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/08\/image8.png\"><img loading=\"lazy\" style=\"display: inline; background-image: none;\" title=\"image\" src=\"http:\/\/looselycoupledlabs.com\/wp-content\/uploads\/2014\/08\/image_thumb8.png\" alt=\"image\" width=\"456\" height=\"109\" border=\"0\" \/><\/a><\/p>\n<h1>Conclusion<\/h1>\n<p>As you can see, it is fairly easy to interrogate RabbitMQ to get information about the status of its queues (as well as any number of other objects). If you want to make extensive use of the HTTP API, I would suggest taking a look at Mike Hadlow\u2019s <a href=\"https:\/\/github.com\/mikehadlow\/EasyNetQ\/wiki\/Management-API-Introduction\" target=\"_blank\">EasyNetQ.Client.Management<\/a> library, available on NuGet. This is a complete C# wrapper around the HTTP API, making it trivial to work with the API from C#.<\/p>\n<p>I hope you found value in this blog post. Please don\u2019t hesitate to contact me if you have any questions or suggestions for future blog posts. Until then\u2026<\/p>\n","protected":false},"excerpt":{"rendered":"<p>We\u2019ve talked a lot about using MassTransit with RabbitMQ in a variety of scenarios on this blog. We talked about error handling, which is something you need to know how to implement in a real world MassTransit + RabbitMQ deployment. Another important aspect to a production deployment is monitoring. Lets take a look at how&#8230; <a class=\"more-link\" href=\"https:\/\/looselycoupledlabs.com\/2014\/08\/monitoring-rabbitmq\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":1,"featured_media":162,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[6],"tags":[3],"_links":{"self":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts\/158"}],"collection":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/comments?post=158"}],"version-history":[{"count":4,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts\/158\/revisions"}],"predecessor-version":[{"id":164,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/posts\/158\/revisions\/164"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/media\/162"}],"wp:attachment":[{"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/media?parent=158"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/categories?post=158"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/looselycoupledlabs.com\/wp-json\/wp\/v2\/tags?post=158"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}